# 选股买卖逻辑与算法文档

本文档详细说明系统的选股逻辑、买卖决策算法、风险控制和仓位管理机制。

## 目录

- [核心投资模型](#核心投资模型)
- [选股逻辑](#选股逻辑)
  - [ETF/基金识别算法](#21-etf基金识别)
  - [行业智能推断](#31-行业分类)
- [风险评分算法](#风险评分算法)
- [市场情绪评分算法](#市场情绪评分算法)
- [目标价格计算算法](#目标价格计算算法)
- [买卖决策逻辑](#买卖决策逻辑)
- [卖出策略](#卖出策略)（新）
- [仓位管理算法](#仓位管理算法)
- [止损策略](#止损策略)
- [建仓策略](#建仓策略)
- [市场预警系统](#市场预警系统)
- [重要经济事件](#14-重要经济事件)（新）

---

## 核心投资模型

### G=B+M 模型（投资投机模型）

系统采用 **G=B+M** 模型作为核心分析框架：

- **G (价格差异)**: 当前价格相对于内在价值的差异
- **B (基本面)**: 公司的财务健康状况和盈利能力
- **M (市场情绪)**: 市场对股票的估值和情绪

**核心公式**: `价格差异(G) = 基本面(B) + 市场情绪(M)`

---

## 选股逻辑

### 1. 数据获取与预处理

#### 1.1 股票代码标准化

系统自动识别市场类型并添加相应后缀，**支持模糊搜索**：

```python
# 港股：4-5位数字 -> 添加 .HK
#   - 支持前面有0的情况（如：09988 或 9988 都识别为 9988.HK）
#   - yfinance要求去掉前导0，所以09988会转换为9988.HK
#   - 原始输入09988和9988都能正确识别
# A股上海：6位数字，600/601/603/688开头 -> 添加 .SS
#   - 优先识别A股（6位数字）
# A股深圳：6位数字，000/001/002/300开头 -> 添加 .SZ
# 美股：默认不加后缀
```

**识别优先级**：
1. **优先识别港股**（如果原始是4-5位数字，优先识别为港股，去掉前导0）
2. **然后识别A股**（6位数字，包含补0的情况）
3. **最后默认为美股**

**港股代码处理规则**：
- 输入 `09988` 或 `9988` → 标准化为 `9988.HK`（yfinance格式要求去掉前导0）
- 输入 `02525` 或 `2525` → 标准化为 `2525.HK`
- yfinance不支持带前导0的港股代码，因此统一去掉前导0

#### 1.2 基础数据获取

**主要数据源**：Yahoo Finance (yfinance)
- **价格数据**: 当前价格、52周高低价、历史价格
- **财务指标**: PE、Forward PE、PEG、营收增长率、利润率
- **技术指标**: 50日均线(MA50)、200日均线(MA200)
- **市场数据**: 市值、成交量、成交量异常检测
- **事件数据**: 财报日期、期权到期日
- **公司信息**: 业务描述、最新新闻（最多5条）

**备用数据源**：Alpha Vantage（仅支持美股）
- 当Yahoo Finance失败或遇到速率限制时自动切换
- 仅支持美股市场数据
- 提供历史价格数据、ATR等技术指标

**数据获取优化**：
- 支持重试机制（默认3次重试，指数退避）
- ETF数据获取时抑制不必要的ERROR日志（ETF没有fundamentals数据是正常的）
- 自动处理网络错误和速率限制

#### 1.3 宏观经济数据

获取以下宏观指标：

- **10年期美债收益率** (^TNX): 反映市场对利率和通胀的预期
- **美元指数** (DX-Y.NYB 或 ^DXY): 反映美元强弱，影响全球流动性
- **黄金价格** (GC=F): 避险情绪指标
- **原油价格** (CL=F): 通胀和经济增长预期

#### 1.4 重要经济事件

系统会获取并分类显示以下经济事件：

**🇺🇸 美国经济事件**：
- 美联储利率决议（FOMC会议，含点阵图标识）
- 美国CPI数据发布
- 期权到期日（月度期权、季度期权/四重到期日）

**🇨🇳 中国经济事件**：
- 央行货币政策会议
- CPI/PPI数据发布
- GDP季度数据发布
- PMI数据发布

**🌍 其他国家**：
- 其他重要经济事件（可扩展）

事件按日期排序，显示距离当前的天数，便于投资者提前规划交易策略。

#### 1.5 期权市场数据

获取以下期权指标：

- **VIX恐慌指数** (^VIX): 市场波动率指标
- **Put/Call比率**: 看跌/看涨期权持仓量比率
- **期权到期日**: 月度期权和季度期权（四重到期日）到期日期

### 2. ETF/基金识别算法

系统首先判断是否为ETF或基金：

#### 2.1 ETF/基金识别

```python
def is_etf_or_fund(data):
    """
    判断是否为ETF或基金
    基于名称、行业、代码关键词匹配
    返回: (是否为ETF/基金, 类型)
    类型: 'ETF', 'REIT', 'Fund', 'Stock'
    """
    # 关键词检测
    etf_keywords = ['etf', 'proshares', 'ultrapro', 'qqq', 'spy', ...]
    fund_keywords = ['fund', 'trust', 'reit', ...]
    
    # 检查名称、行业、代码中是否包含关键词
    # 返回识别结果
```

#### 2.2 ETF分析框架

对于ETF/基金，使用特殊分析框架：
- **不适用**公司财务指标（营收、利润、PE等）
- **重点分析**：跟踪标的指数、跟踪误差、管理费率、流动性
- **技术面分析**：价格位置、均线、52周区间
- **杠杆ETF风险**：特别标注杠杆倍数和风险（如TQQQ的3x杠杆）

### 3. 公司分类算法

系统根据以下维度对公司进行分类：

#### 3.1 行业分类

**行业智能推断**（新功能）：
- 当Yahoo Finance数据缺失时（如新上市公司）
- 根据公司名称中的关键词推断行业
- 支持中英文关键词匹配
- 根据A股代码规则推断（688→科技，300→创业板）

```python
行业类别 = {
    'technology': ['technology', 'software', 'internet', 'semiconductor'],
    'financial': ['financial', 'bank', 'insurance', 'finance'],
    'healthcare': ['healthcare', 'pharmaceutical', 'biotech', 'medical'],
    'energy': ['energy', 'oil', 'gas', 'petroleum'],
    'consumer': ['consumer', 'retail', 'consumer goods'],
    'real_estate': ['real estate', 'reit', 'property'],
    'utility': ['utility', 'utilities', 'electric']
}
```

#### 2.2 成长阶段分类

```python
if 营收增长率 > 20%:
    成长阶段 = 'high_growth'  # 高成长
elif 营收增长率 > 10%:
    成长阶段 = 'growth'       # 成长
elif 营收增长率 > 0%:
    成长阶段 = 'stable'       # 稳定
else:
    成长阶段 = 'declining'    # 衰退
```

#### 2.3 市值分类

```python
if 市值 > 1000亿美元:
    市值类别 = 'large_cap'    # 大盘股
elif 市值 > 100亿美元:
    市值类别 = 'mid_cap'      # 中盘股
else:
    市值类别 = 'small_cap'    # 小盘股
```

### 3. 选股筛选条件

系统不进行主动筛选，而是对用户输入的股票进行**评估和评分**。评估维度包括：

#### 3.1 基本面筛选（B维度）

**合格标准**:
- 营收增长率 ≥ 0%（避免衰退公司）
- 利润率 ≥ 5%（避免低效公司）
- PE > 0（有盈利）

**优质标准**:
- 营收增长率 ≥ 15%（高成长）
- 利润率 ≥ 15%（高盈利）
- PEG < 1.5（增长匹配估值）

#### 3.2 估值筛选（M维度）

**合理估值标准**:
- PE < 40（避免过度估值）
- PEG < 1.5（增长匹配估值）
- 价格位置 < 80%（避免追高）

**价值股标准**:
- PE < 15
- PEG < 1.0
- 价格位置 < 50%

#### 3.3 技术面筛选

**多头趋势标准**:
- 价格 > MA50
- MA50 > MA200
- 价格位置 < 70%

**突破标准**:
- 价格突破52周高点
- 成交量放大（>2倍平均成交量）

---

## 风险评分算法

### 1. 风险评分计算流程

风险评分为 **0-10分**，分数越高表示风险越大。

#### 1.1 G=B+M 模型风险检测

```python
风险分数 = 0

# M (情绪) 检测: 估值过热
if PE > 60 and 营收增长率 < 30%:
    风险分数 += 3
    风险标志.append("M: 估值过高且增长不匹配 (PE>60)")
elif PE > 40:
    风险分数 += 1

# B (基本面) 检测: 财务健康度
if 营收增长率 < 0:
    风险分数 += 3
    风险标志.append("B: 营收负增长 (衰退迹象)")
if 利润率 < 5%:
    风险分数 += 1
    风险标志.append("B: 利润率极低 (<5%)")

# 技术面 (趋势) - 投机风控
if 价格 < MA200:
    风险分数 += 2
    风险标志.append("技术: 价格跌破200日均线 (熊市趋势)")
```

#### 1.2 投资风格适配风险检测

```python
# 风格特定的红线
if 投资风格 == 'value' and PE > 25:
    风险分数 += 2
    风险标志.append("风格不符: 价值股 PE > 25")

if 投资风格 == 'growth' and 营收增长率 < 15%:
    风险分数 += 2
    风险标志.append("风格不符: 成长股增速 < 15%")
```

### 2. 风险等级分类

```python
if 风险分数 >= 6:
    风险等级 = "极高 (建议观望)"
elif 风险分数 >= 4:
    风险等级 = "高"
elif 风险分数 >= 2:
    风险等级 = "中"
else:
    风险等级 = "低"
```

### 3. 风险评分与仓位调整

| 风险分数 | 风险等级 | 仓位调整系数 | 建议操作 |
|---------|---------|------------|---------|
| 0-2 | 低 | 100% | 可以建仓 |
| 2-4 | 中 | 70% | 谨慎建仓 |
| 4-6 | 高 | 40% | 少量建仓 |
| 6-10 | 极高 | 0% | 不建议建仓 |

---

## 市场情绪评分算法

### 1. 市场情绪评分计算

市场情绪评分为 **0-10分**，分数越高表示市场情绪越乐观。

#### 1.1 评分权重分配

```python
市场情绪分数 = 0

# 1. PE估值情绪 (权重30%)
PE情绪分数 = 根据PE计算情绪分数(0-10分)
市场情绪分数 += PE情绪分数 * 0.30

# 2. PEG情绪调整 (权重15%)
PEG情绪分数 = 根据PEG计算情绪分数(0-10分)
市场情绪分数 += PEG情绪分数 * 0.15

# 3. 价格位置情绪 (权重25%)
价格位置 = (当前价格 - 52周低点) / (52周高点 - 52周低点)
位置情绪分数 = 根据价格位置计算情绪分数(0-10分)
市场情绪分数 += 位置情绪分数 * 0.25

# 4. 技术面情绪 (权重10%)
if 价格 > MA50 and MA50 > MA200:
    技术情绪分数 = 7.0  # 多头排列
elif 价格 < MA200:
    技术情绪分数 = 3.0  # 跌破长期均线
else:
    技术情绪分数 = 5.0  # 震荡
市场情绪分数 += 技术情绪分数 * 0.10

# 5. 期权市场情绪 (权重20%)
# 5.1 VIX恐慌指数 (权重12%)
VIX情绪分数 = 根据VIX计算情绪分数(0-10分)
市场情绪分数 += VIX情绪分数 * 0.12

# 5.2 Put/Call比率 (权重8%)
PC情绪分数 = 根据Put/Call比率计算情绪分数(0-10分)
市场情绪分数 += PC情绪分数 * 0.08

# 6. 宏观经济情绪调整 (权重10%)
# 6.1 美债收益率 (权重4%)
美债情绪分数 = 根据10年美债收益率计算情绪分数(0-10分)
市场情绪分数 += 美债情绪分数 * 0.04

# 6.2 美元指数 (权重3%)
美元情绪分数 = 根据美元指数计算情绪分数(0-10分)
市场情绪分数 += 美元情绪分数 * 0.03

# 6.3 黄金价格 (权重2%)
黄金情绪分数 = 根据黄金价格变化计算情绪分数(0-10分)
市场情绪分数 += 黄金情绪分数 * 0.02

# 6.4 原油价格 (权重1%)
原油情绪分数 = 根据原油价格变化计算情绪分数(0-10分)
市场情绪分数 += 原油情绪分数 * 0.01

# 7. 期权到期日影响 (权重2%)
期权到期影响 = 根据期权到期日距离计算影响分数(-2.0到0分)
市场情绪分数 += 期权到期影响 * 0.02

# 确保分数在0-10范围内
市场情绪分数 = max(0, min(10, 市场情绪分数))
```

#### 1.2 VIX情绪分数计算

```python
def 计算VIX情绪分数(vix, vix_change):
    if vix < 15:
        情绪分数 = 8.0  # 低波动，市场平静
    elif vix < 20:
        情绪分数 = 6.5  # 正常波动
    elif vix < 25:
        情绪分数 = 5.0  # 中等偏高波动
    elif vix < 30:
        情绪分数 = 3.5  # 高波动
    elif vix < 40:
        情绪分数 = 2.0  # 很高波动
    else:
        情绪分数 = 1.0  # 极高波动，极度恐慌
    
    # VIX快速上升进一步降低情绪
    if vix_change > 10%:
        情绪分数 = max(1.0, 情绪分数 - 1.5)
    elif vix_change > 5%:
        情绪分数 = max(1.0, 情绪分数 - 0.8)
    elif vix_change < -10%:
        情绪分数 = min(10.0, 情绪分数 + 1.0)
    
    return 情绪分数
```

#### 1.3 Put/Call比率情绪分数计算

```python
def 计算PC情绪分数(pc_ratio):
    if pc_ratio < 0.7:
        情绪分数 = 7.5  # 看涨情绪强
    elif pc_ratio < 0.9:
        情绪分数 = 6.0  # 略偏看涨
    elif pc_ratio < 1.1:
        情绪分数 = 5.0  # 中性
    elif pc_ratio < 1.3:
        情绪分数 = 4.0  # 略偏看跌
    elif pc_ratio < 1.5:
        情绪分数 = 3.0  # 看跌情绪较强
    else:
        情绪分数 = 2.0  # 极度看跌（可能负Gamma风险）
    
    return 情绪分数
```

---

## 目标价格计算算法

### 0. ETF/基金估值方法（特殊处理）

**重要**：对于ETF和基金，使用与普通股票不同的估值方法，因为ETF不适用公司财务指标（PE、PEG等）。

#### 0.1 ETF估值算法

```python
if is_etf_or_fund:
    week52_high = data.get('week52_high', current_price)
    week52_low = data.get('week52_low', current_price)
    ma50 = data.get('ma50', current_price)
    ma200 = data.get('ma200', current_price)
    
    if current_price > ma50 and ma50 > ma200:
        # 上升趋势：目标价偏向52周高点，但限制在110%以内
        target_price = min(week52_high, current_price * 1.1)
    else:
        # 下降或震荡趋势：目标价为52周中位数
        target_price = (week52_high + week52_low) / 2
```

**ETF估值逻辑**：
- **不适用**PE/PEG等财务指标估值方法
- 主要基于**技术面分析**和**52周价格区间**
- 上升趋势（价格>MA50>MA200）时，目标价偏向52周高点，但限制涨幅不超过10%
- 下降或震荡趋势时，目标价为52周高低点的中位数
- 这种方法更符合ETF跟踪指数的特性

**注意**：ETF估值方法会在前端显示中明确标注，不显示PE/PEG等不适用指标。

### 1. 普通股票：多维度估值模型

对于普通股票，目标价格采用**加权平均**的方式，结合多种估值方法：

#### 1.1 估值方法

**方法1: PE/PEG估值法**（适用于有盈利的公司）

```python
if 有Forward PE:
    目标价格 = 当前价格 * (合理PE / Forward PE)
else:
    if PE > 合理PE * 1.5:
        目标价格 = 当前价格 * (合理PE / PE)  # PE过高，下调
    elif PE < 合理PE * 0.7:
        目标价格 = 当前价格 * (合理PE / PE) * 0.9  # PE偏低，有上涨空间
    else:
        目标价格 = 当前价格 * (合理PE / PE) * 0.95  # PE合理，适度溢价
```

**方法2: PEG估值法**（适用于成长股）

```python
if PEG > 0 and 营收增长率 > 0:
    合理PEG = 1.0  # 默认合理PEG
    if 成长阶段 == 'high_growth':
        合理PEG = 1.2  # 高成长可以容忍更高PEG
    elif 成长阶段 == 'declining':
        合理PEG = 0.8  # 衰退公司PEG应该更低
    
    if PEG < 合理PEG:
        PEG倍数 = 合理PEG / PEG
        目标价格 = 当前价格 * min(PEG倍数, 1.5)  # 限制最大涨幅
```

**方法3: 增长率折现法**（适用于成长股）

```python
if 营收增长率 > 0:
    if 成长阶段 == 'high_growth':
        增长倍数 = 1 + 营收增长率 * 0.6  # 给予60%的增长溢价
    elif 成长阶段 == 'growth':
        增长倍数 = 1 + 营收增长率 * 0.4  # 给予40%的增长溢价
    elif 成长阶段 == 'stable':
        增长倍数 = 1 + 营收增长率 * 0.2  # 给予20%的增长溢价
    else:
        增长倍数 = 1.0  # 衰退公司不给增长溢价
    
    # 如果利润率较高，可以给予更高估值
    if 利润率 > 15%:
        增长倍数 *= 1.1
    
    目标价格 = 当前价格 * 增长倍数
```

**方法4: 技术面目标价**（适用于所有公司）

```python
价格位置 = (当前价格 - 52周低点) / (52周高点 - 52周低点)

if 价格位置 < 0.3:
    # 价格在低位
    if 价格 > MA50 and MA50 > MA200:
        技术目标价 = 52周高点  # 多头排列，目标价可以是52周高点
    else:
        技术目标价 = (52周高点 + 52周低点) / 2  # 技术面一般，目标价保守
elif 价格位置 < 0.7:
    # 价格在中位
    if 价格 > MA50 and MA50 > MA200:
        技术目标价 = 52周高点
    else:
        技术目标价 = 当前价格 * 1.15
else:
    # 价格在高位，目标价保守
    技术目标价 = 当前价格 * 1.10
```

#### 1.2 合理PE计算

```python
def 计算合理PE(行业类别, 成长阶段, 投资风格):
    # 基础PE（根据行业）
    基础PE = {
        'technology': 25,
        'healthcare': 22,
        'financial': 12,
        'energy': 15,
        'consumer': 18,
        'real_estate': 15,
        'utility': 16,
        'general': 18
    }.get(行业类别, 18)
    
    # 根据成长阶段调整
    if 成长阶段 == 'high_growth':
        基础PE *= 1.3  # 高成长公司可以容忍更高PE
    elif 成长阶段 == 'growth':
        基础PE *= 1.15
    elif 成长阶段 == 'stable':
        基础PE *= 1.0
    elif 成长阶段 == 'declining':
        基础PE *= 0.7  # 衰退公司PE应该更低
    
    # 根据投资风格调整
    if 投资风格 == 'value':
        基础PE *= 0.75  # 价值风格要求更低PE
    elif 投资风格 == 'growth':
        基础PE *= 1.2  # 成长风格可以容忍更高PE
    elif 投资风格 == 'quality':
        基础PE *= 1.0  # 质量风格保持基准
    elif 投资风格 == 'momentum':
        基础PE *= 1.1  # 趋势风格略高
    
    return 基础PE
```

#### 1.3 加权平均计算

```python
# 根据行业类别分配权重
if 行业类别 in ['technology', 'healthcare']:
    # 科技和医疗：更重视增长率和PEG
    权重 = {
        'PE估值': 0.25,
        'PEG估值': 0.30,
        '增长率折现': 0.30,
        '技术面分析': 0.15
    }
elif 行业类别 == 'financial':
    # 金融：更重视PE
    权重 = {
        'PE估值': 0.50,
        'PEG估值': 0.20,
        '增长率折现': 0.15,
        '技术面分析': 0.15
    }
elif 行业类别 in ['energy', 'utility']:
    # 能源和公用事业：更重视PE和技术面
    权重 = {
        'PE估值': 0.40,
        'PEG估值': 0.15,
        '增长率折现': 0.20,
        '技术面分析': 0.25
    }
else:
    # 其他行业：均衡权重
    权重 = {
        'PE估值': 0.35,
        'PEG估值': 0.25,
        '增长率折现': 0.25,
        '技术面分析': 0.15
    }

# 计算加权平均
加权总和 = 0
总权重 = 0
for 方法, 价格 in 各方法目标价格.items():
    加权总和 += 价格 * 权重[方法]
    总权重 += 权重[方法]

平均目标价 = 加权总和 / 总权重
```

#### 1.4 风险调整

```python
# 根据风险评分调整
风险分数 = 风险评分结果['score']
if 风险分数 >= 6:
    风险调整系数 = 0.85  # 高风险，目标价格下调15%
elif 风险分数 >= 4:
    风险调整系数 = 0.95  # 中等风险，目标价格下调5%
elif 风险分数 >= 2:
    风险调整系数 = 1.0   # 低风险，不调整
else:
    风险调整系数 = 1.05  # 极低风险，可以稍微乐观

调整后目标价 = 平均目标价 * 风险调整系数
```

#### 1.5 风格调整

```python
# 根据投资风格进行最终调整
if 投资风格 == 'value':
    最终目标价 = 调整后目标价 * 0.95  # 价值风格更保守
elif 投资风格 == 'growth':
    最终目标价 = 调整后目标价 * 1.05  # 成长风格可以稍微乐观
elif 投资风格 == 'momentum':
    最终目标价 = 调整后目标价 * 1.08  # 趋势风格可以更乐观
else:
    最终目标价 = 调整后目标价

# 确保目标价格在合理范围内
# 最低不低于当前价格的80%，最高不超过当前价格的250%
最终目标价 = max(当前价格 * 0.8, min(最终目标价, 当前价格 * 2.5))
```

---

## 买卖决策逻辑

### 1. 买入决策流程

#### 1.1 买入条件检查

```python
def 是否应该买入(风险评分, 市场情绪, 目标价格, 当前价格):
    # 条件1: 风险评分不能过高
    if 风险评分 >= 6:
        return False, "风险过高，不建议买入"
    
    # 条件2: 目标价格应该高于当前价格（有上涨空间）
    if 目标价格 <= 当前价格:
        return False, "目标价格不高于当前价格，上涨空间有限"
    
    # 条件3: 市场情绪不能过于悲观
    if 市场情绪 < 3.0:
        return False, "市场情绪过于悲观，建议观望"
    
    # 条件4: 价格位置不能过高（避免追高）
    价格位置 = (当前价格 - 52周低点) / (52周高点 - 52周低点)
    if 价格位置 > 0.9:
        return False, "价格位置过高，追高风险大"
    
    return True, "可以买入"
```

#### 1.2 买入信号强度

```python
def 计算买入信号强度(风险评分, 市场情绪, 目标价格, 当前价格):
    信号强度 = 0
    
    # 风险评分越低，信号越强
    信号强度 += (10 - 风险评分) * 10
    
    # 市场情绪越高，信号越强
    信号强度 += 市场情绪 * 5
    
    # 上涨空间越大，信号越强
    上涨空间 = (目标价格 - 当前价格) / 当前价格
    信号强度 += 上涨空间 * 100
    
    # 价格位置越低，信号越强
    价格位置 = (当前价格 - 52周低点) / (52周高点 - 52周低点)
    信号强度 += (1 - 价格位置) * 20
    
    return 信号强度  # 0-200分，分数越高信号越强
```

### 2. 卖出决策流程

#### 2.1 卖出条件检查

```python
def 是否应该卖出(当前价格, 买入价格, 目标价格, 止损价格, 风险评分):
    # 条件1: 达到目标价格
    if 当前价格 >= 目标价格:
        return True, "达到目标价格，建议卖出"
    
    # 条件2: 触发止损
    if 当前价格 <= 止损价格:
        return True, "触发止损，必须卖出"
    
    # 条件3: 风险评分大幅上升（基本面恶化）
    if 风险评分 >= 6:
        return True, "风险大幅上升，建议减仓或卖出"
    
    # 条件4: 价格位置过高（获利了结）
    价格位置 = (当前价格 - 52周高点) / (52周高点 - 52周低点)
    if 价格位置 > 0.9 and 当前价格 > 买入价格 * 1.2:
        return True, "价格位置过高且已有20%以上收益，建议获利了结"
    
    return False, "继续持有"
```

#### 2.2 卖出信号强度

```python
def 计算卖出信号强度(当前价格, 买入价格, 目标价格, 止损价格, 风险评分):
    信号强度 = 0
    
    # 触发止损，必须卖出
    if 当前价格 <= 止损价格:
        return 100  # 最高优先级
    
    # 达到目标价格，建议卖出
    if 当前价格 >= 目标价格:
        信号强度 += 80
    
    # 风险大幅上升
    if 风险评分 >= 6:
        信号强度 += 60
    
    # 获利了结
    收益率 = (当前价格 - 买入价格) / 买入价格
    if 收益率 > 0.2:  # 20%以上收益
        信号强度 += 40
    
    return 信号强度  # 0-100分，分数越高信号越强
```

---

## 仓位管理算法

### 1. 基础仓位上限

根据投资风格确定基础仓位上限：

```python
基础仓位上限 = {
    'quality': 20%,   # 质量风格：最大仓位20%
    'value': 10%,     # 价值风格：最大仓位10%
    'growth': 15%,    # 成长风格：最大仓位15%
    'momentum': 5%    # 趋势风格：最大仓位5%
}.get(投资风格, 10%)
```

### 2. 风险调整仓位

```python
def 计算建议仓位(基础仓位上限, 风险评分):
    # 风险调整系数
    if 风险评分 >= 6:
        调整系数 = 0.0   # 极高风险不买
    elif 风险评分 >= 4:
        调整系数 = 0.4   # 高风险，仓位降至40%
    elif 风险评分 >= 2:
        调整系数 = 0.7   # 中等风险，仓位降至70%
    else:
        调整系数 = 1.0   # 低风险，使用100%基础仓位
    
    建议仓位 = 基础仓位上限 * 调整系数
    
    return round(建议仓位, 1)
```

### 3. 仓位管理原则

1. **单只股票仓位限制**: 不超过基础仓位上限
2. **总仓位控制**: 建议总仓位不超过80%（保留20%现金）
3. **分散投资**: 建议持有5-10只股票，避免过度集中
4. **动态调整**: 根据风险评分和市场环境动态调整仓位

---

## 止损策略

### 1. 止损价格计算

```python
止损价格 = 当前价格 * 0.85  # 默认15%止损
```

### 2. 止损触发条件

1. **价格触发**: 当前价格 ≤ 止损价格
2. **基本面恶化**: 风险评分 ≥ 6
3. **技术面破位**: 价格跌破关键支撑位（如MA200）

### 3. 止损执行原则

1. **严格执行**: 一旦触发止损，必须立即卖出
2. **不抱侥幸**: 不要因为"可能反弹"而延迟止损
3. **分批止损**: 如果仓位较大，可以分批止损，但不要拖延

---

## 建仓策略

### 1. 建仓方式选择

```python
def 确定建仓方式(风险评分, 建议仓位):
    if 风险评分 >= 6:
        return "不建议建仓"
    elif 风险评分 >= 4:
        return "分批建仓"  # 高风险，分批建仓
    elif 风险评分 >= 2:
        return "分批建仓"  # 中等风险，分批建仓
    else:
        return "可以一次性建仓"  # 低风险，可以一次性建仓
```

### 2. 分批建仓策略

#### 2.1 高风险情况（风险评分 ≥ 4）

```python
建仓批次 = 3批
每批仓位 = 建议仓位 / 3
时间间隔 = 1-2周

# 第一批：立即建仓 33%
# 第二批：1-2周后建仓 33%
# 第三批：再1-2周后建仓 34%
```

#### 2.2 中等风险情况（风险评分 2-4）

```python
建仓批次 = 2批
每批仓位 = 建议仓位 / 2
时间间隔 = 1周

# 第一批：立即建仓 50%
# 第二批：1周后建仓 50%
```

#### 2.3 低风险情况（风险评分 < 2）

```python
建仓批次 = 1批
每批仓位 = 建议仓位

# 一次性建仓 100%
```

### 3. 建仓时机选择

1. **价格回调**: 等待价格回调至支撑位附近
2. **技术突破**: 等待技术面突破确认
3. **市场环境**: 避免在市场恐慌时建仓（VIX > 30）
4. **重要事件**: 避免在财报发布、美联储会议等重要事件前建仓

---

## 市场预警系统

### 1. VIX预警

```python
if VIX >= 30:
    预警级别 = 'high'
    预警消息 = 'VIX已处于高位，市场恐慌情绪严重'
    建议操作 = '立即降低仓位或保持观望'
elif VIX >= 25:
    预警级别 = 'medium'
    预警消息 = 'VIX接近危险区域，需密切关注'
    建议操作 = '谨慎操作，降低仓位'
elif VIX >= 20 and VIX变化 > 5%:
    预警级别 = 'medium'
    预警消息 = 'VIX快速上升，可能继续攀升'
    建议操作 = '保持警惕'
```

### 2. Put/Call比率预警

```python
if Put/Call比率 >= 1.5:
    预警级别 = 'high'
    预警消息 = 'Put/Call比率极高，看跌情绪强烈，存在负Gamma风险'
    建议操作 = '立即降低仓位'
elif Put/Call比率 >= 1.2:
    预警级别 = 'medium'
    预警消息 = 'Put/Call比率偏高，接近危险区域'
    建议操作 = '谨慎操作'
```

### 3. 美债收益率预警

```python
if 10年美债收益率 >= 5.0%:
    预警级别 = 'high'
    预警消息 = '10年美债收益率极高，流动性严重收紧'
    建议操作 = '降低风险敞口'
elif 10年美债收益率 >= 4.5%:
    预警级别 = 'medium'
    预警消息 = '10年美债收益率偏高，流动性收紧'
    建议操作 = '保持警惕'
```

### 4. 重要事件预警

#### 4.1 美联储利率决议

```python
if 距离美联储会议 <= 3天:
    预警级别 = 'high'
    预警消息 = '美联储利率决议即将举行，市场波动可能加剧'
    建议操作 = '提前调整仓位或保持观望'
elif 距离美联储会议 <= 7天:
    预警级别 = 'medium'
    预警消息 = '美联储利率决议即将举行，建议关注'
    建议操作 = '谨慎操作'
```

#### 4.2 CPI数据发布

```python
if 距离CPI发布 <= 3天:
    预警级别 = 'high'
    预警消息 = 'CPI数据即将发布，市场波动可能加剧'
    建议操作 = '提前调整仓位'
elif 距离CPI发布 <= 7天:
    预警级别 = 'medium'
    预警消息 = 'CPI数据即将发布，建议关注'
    建议操作 = '谨慎操作'
```

#### 4.3 期权到期日（交割日）

```python
if 距离期权到期日 <= 1天:
    预警级别 = 'high'
    预警消息 = '期权到期日，市场波动风险极高'
    建议操作 = '降低整体仓位或保持观望'
elif 距离期权到期日 <= 3天:
    预警级别 = 'high'
    预警消息 = '期权到期日临近，市场波动风险高'
    建议操作 = '谨慎操作'
elif 距离期权到期日 <= 7天:
    预警级别 = 'medium'
    预警消息 = '期权到期日临近，市场波动风险增加'
    建议操作 = '降低仓位或保持观望'
```

### 5. 成交量异常预警

```python
if 成交量比率 > 3.0:
    预警级别 = 'high'
    预警消息 = '成交量异常放大，可能存在重大消息或资金异动'
    建议操作 = '密切关注，谨慎操作'
elif 成交量比率 > 2.0:
    预警级别 = 'medium'
    预警消息 = '成交量明显放大，需密切关注'
    建议操作 = '保持警惕'
```

### 6. 地缘政治风险预警

```python
if 地缘政治风险指数 >= 7:
    预警级别 = 'high'
    预警消息 = '地缘政治风险指数极高，市场避险情绪强烈'
    建议操作 = '降低风险敞口，增加防御性资产配置'
elif 地缘政治风险指数 >= 6:
    预警级别 = 'medium'
    预警消息 = '地缘政治风险指数偏高，需保持警惕'
    建议操作 = '谨慎操作'
```

---

## 算法总结

### 核心算法流程

1. **数据获取**: 获取股票基础数据、宏观经济数据、期权市场数据
2. **公司分类**: 根据行业、成长阶段、市值对公司进行分类
3. **风险评分**: 基于G=B+M模型计算风险评分（0-10分）
4. **市场情绪**: 计算市场情绪评分（0-10分）
5. **目标价格**: 使用多维度估值模型计算目标价格
6. **仓位建议**: 根据投资风格和风险评分计算建议仓位
7. **买卖决策**: 基于风险评分、市场情绪、目标价格做出买卖决策
8. **市场预警**: 生成市场预警信息，提醒风险事件

### 关键参数

- **风险评分阈值**: 6分（极高风险，不建议建仓）
- **止损幅度**: 15%
- **基础仓位上限**: Quality 20%, Value 10%, Growth 15%, Momentum 5%
- **VIX危险阈值**: 30（极高恐慌）
- **Put/Call危险阈值**: 1.5（极度看跌）

### 投资风格特点

| 投资风格 | 最大仓位 | 持有周期 | 核心关注点 |
|---------|---------|---------|-----------|
| Quality | 20% | 长期(1-3年) | 财务稳健、护城河深 |
| Value | 10% | 中期(6-12个月) | 低PE、低PEG、安全边际 |
| Growth | 15% | 中短期(3-6个月) | 高营收增长、持续增长 |
| Momentum | 5% | 短期(1-3个月) | 技术面突破、价格动量 |

---

## 注意事项

1. **本系统仅供学习和研究使用，不构成投资建议**
2. **所有投资决策应基于您自己的研究和判断**
3. **投资有风险，入市需谨慎**
4. **建议结合其他数据源和专家意见**
5. **定期复查和调整策略参数**

---

## 算法优化建议

本文档基于专业评估，识别出当前算法中存在的**硬编码（Hard-coded）**和**线性化**问题，并提出针对性的优化方案。这些优化将显著提升系统在极端市场环境下的适应性和准确性。

### 优化建议概览

| 优化项 | 当前问题 | 优化方案 | 优先级 | 实现难度 |
|--------|---------|---------|--------|---------|
| PE分位点 | 只看绝对PE值 | 引入历史PE百分位 | 高 | 中 |
| PEG非线性修正 | 固定阈值1.5 | 根据美债收益率动态调整 | 高 | 低 |
| 目标价格计算 | 魔法数字0.6 | PEG估值法/彼得·林奇法 | 中 | 中 |
| ATR动态止损 | 固定15%止损 | 基于ATR的动态止损 | 高 | 中 |
| 行业分类细化 | 7大类过粗 | 增加二级行业标签 | 中 | 低 |
| 动态行业PE基准 | 硬编码PE值 | 使用ETF实时PE | 中 | 中 |
| 数据源优化 | Yahoo Finance限制 | 接入专业API | 低 | 高 |

---

### 1. 估值逻辑优化：PE分位点与B/M界限

#### 1.1 当前问题

**问题描述**：
- 在"市场情绪评分"中，PE作为核心因子（权重30%），但PE更多属于**基本面(B)**或**估值**范畴
- 只看绝对PE值（如PE<40），忽略了历史相对位置
- 例如：某消费股PE=25可能不算高，但如果处于历史90%分位，说明情绪极度乐观

**影响**：
- 在极端市场下，绝对PE值会失真
- 无法准确识别估值泡沫或低估机会

#### 1.2 优化方案：引入PE分位点

**核心思路**：使用**Current PE Percentile**（当前PE处于过去5年/10年的百分位）替代绝对PE值。

**算法实现**：

```python
def 计算PE分位点(当前PE, 历史PE数据, 时间窗口='5年'):
    """
    计算当前PE在历史数据中的百分位
    
    参数:
        当前PE: 当前市盈率
        历史PE数据: 过去5年或10年的PE历史数据（列表或数组）
        时间窗口: '5年' 或 '10年'
    
    返回:
        pe_percentile: 0-100的百分位值
        pe_z_score: Z分数（标准化后的偏离度）
    """
    if len(历史PE数据) < 20:  # 数据不足，使用默认值
        return 50.0, 0.0  # 默认中位数
    
    # 计算百分位
    pe_percentile = (sum(1 for pe in 历史PE数据 if pe < 当前PE) / len(历史PE数据)) * 100
    
    # 计算Z分数（标准化偏离度）
    import numpy as np
    mean_pe = np.mean(历史PE数据)
    std_pe = np.std(历史PE数据)
    if std_pe > 0:
        pe_z_score = (当前PE - mean_pe) / std_pe
    else:
        pe_z_score = 0.0
    
    return pe_percentile, pe_z_score


def 基于PE分位点的情绪评分(当前PE, PE分位点, PE_Z分数):
    """
    基于PE分位点计算市场情绪分数
    
    情绪评分规则:
    - PE分位点 < 20%: 情绪悲观，分数 2.0-4.0
    - PE分位点 20-40%: 情绪偏悲观，分数 4.0-5.5
    - PE分位点 40-60%: 情绪中性，分数 5.0-6.0
    - PE分位点 60-80%: 情绪偏乐观，分数 6.0-7.5
    - PE分位点 80-90%: 情绪乐观，分数 7.5-8.5
    - PE分位点 > 90%: 情绪极度乐观（可能泡沫），分数 8.5-9.5
    """
    if PE分位点 < 20:
        基础情绪 = 3.0
    elif PE分位点 < 40:
        基础情绪 = 4.5
    elif PE分位点 < 60:
        基础情绪 = 5.5
    elif PE分位点 < 80:
        基础情绪 = 6.5
    elif PE分位点 < 90:
        基础情绪 = 8.0
    else:
        基础情绪 = 9.0  # 极度乐观，可能泡沫
    
    # Z分数调整（极端偏离时进一步调整）
    if abs(PE_Z分数) > 2.0:  # 超过2个标准差
        if PE_Z分数 > 0:
            基础情绪 = min(10.0, 基础情绪 + 0.5)  # 进一步乐观
        else:
            基础情绪 = max(0.0, 基础情绪 - 0.5)  # 进一步悲观
    
    return 基础情绪
```

**数据获取**：
- 需要获取至少5年的历史PE数据
- 可以从Yahoo Finance获取历史财务数据，计算历史PE
- 或使用专业数据源（如Alpha Vantage, FMP Cloud）

**实施优先级**：**高** - 这是最核心的优化，能显著提升估值准确性

---

### 2. PEG非线性修正：基于美债收益率

#### 2.1 当前问题

**问题描述**：
- PEG阈值固定为1.5，缺乏市场环境适应性
- 在高利率环境下，市场对PEG的容忍度会大幅降低
- 在低利率环境下，市场对PEG的容忍度会提高

**影响**：
- 无法适应不同利率环境下的估值逻辑
- 可能在高利率时高估成长股，在低利率时低估成长股

#### 2.2 优化方案：动态PEG阈值

**核心思路**：引入**10年美债收益率**作为PEG阈值的修正系数。

**算法实现**：

```python
def 计算动态PEG阈值(10年美债收益率, 基础PEG阈值=1.0):
    """
    根据10年美债收益率动态调整PEG阈值
    
    逻辑:
    - 美债收益率高 -> 资金成本高 -> 对成长股要求更严格 -> PEG阈值降低
    - 美债收益率低 -> 资金成本低 -> 对成长股容忍度提高 -> PEG阈值提高
    
    参数:
        10年美债收益率: 当前10年期美债收益率（百分比，如4.5表示4.5%）
        基础PEG阈值: 基准PEG阈值（通常为1.0）
    
    返回:
        调整后的PEG阈值
    """
    # 基准利率假设为3.0%（历史平均）
    基准利率 = 3.0
    
    # 计算利率偏离度
    利率偏离 = 10年美债收益率 - 基准利率
    
    # 调整系数：每1%的利率偏离，PEG阈值调整0.15
    # 利率上升1% -> PEG阈值降低0.15（更严格）
    # 利率下降1% -> PEG阈值提高0.15（更宽松）
    调整系数 = 1.0 - (利率偏离 * 0.15)
    
    # 限制调整范围：PEG阈值在0.5-2.0之间
    动态PEG阈值 = max(0.5, min(2.0, 基础PEG阈值 * 调整系数))
    
    return 动态PEG阈值


def 基于动态PEG的情绪评分(PEG, 动态PEG阈值):
    """
    使用动态PEG阈值计算情绪分数
    """
    if PEG < 动态PEG阈值 * 0.7:
        情绪分数 = 8.0  # PEG很低，增长预期高
    elif PEG < 动态PEG阈值:
        情绪分数 = 6.0  # PEG合理，增长匹配估值
    elif PEG < 动态PEG阈值 * 1.3:
        情绪分数 = 5.0  # PEG略高，中性
    else:
        情绪分数 = 3.0  # PEG过高，增长不匹配
    
    return 情绪分数
```

**示例**：
- 美债收益率 = 5.0%（高利率环境）
  - 动态PEG阈值 = 1.0 * (1.0 - (5.0-3.0) * 0.15) = 0.7
  - 更严格的估值标准
  
- 美债收益率 = 2.0%（低利率环境）
  - 动态PEG阈值 = 1.0 * (1.0 - (2.0-3.0) * 0.15) = 1.15
  - 更宽松的估值标准

**实施优先级**：**高** - 实现简单，效果显著

---

### 3. 目标价格计算优化：消除"魔法数字"

#### 3.1 当前问题

**问题描述**：
- 增长率折现法中使用 `1 + 营收增长率 * 0.6` 这样的公式
- **0.6** 这个系数缺乏理论支撑
- 线性折现在复利效应下会严重低估高增长股多年后的价值，或在低增长时高估价值

**影响**：
- 目标价格计算不准确
- 对高增长股和低增长股的处理不够精细

#### 3.2 优化方案A：PEG Ratio Valuation

**核心思路**：使用PEG比率估值法，基于盈利增长而非营收增长。

**算法实现**：

```python
def PEG估值法计算目标价格(当前价格, 当前PE, 预期盈利增长率, 合理PEG=1.0):
    """
    使用PEG比率估值法计算目标价格
    
    公式: 目标PE = 合理PEG * 预期盈利增长率
    目标价格 = 当前价格 * (目标PE / 当前PE)
    
    参数:
        当前价格: 当前股价
        当前PE: 当前市盈率
        预期盈利增长率: 未来1-2年的预期盈利增长率（如0.25表示25%）
        合理PEG: 合理的PEG比率（通常为1.0，可根据行业调整）
    
    返回:
        目标价格
    """
    # 计算目标PE
    目标PE = 合理PEG * (1 + 预期盈利增长率)  # 如果增长率是25%，则目标PE = 1.0 * 1.25 = 1.25
    
    # 限制目标PE的合理范围（避免极端值）
    目标PE = max(5.0, min(50.0, 目标PE))
    
    # 计算目标价格
    if 当前PE > 0:
        目标价格 = 当前价格 * (目标PE / 当前PE)
    else:
        目标价格 = 当前价格 * 1.1  # 如果PE无效，使用保守估计
    
    return 目标价格
```

#### 3.3 优化方案B：彼得·林奇估值法变体

**核心思路**：使用彼得·林奇的简化估值模型。

**算法实现**：

```python
def 彼得林奇估值法(净利润, 营收增长率, 股息率=0, 合理PE倍数=15):
    """
    彼得·林奇估值法变体
    
    公式: 合理市值 = 净利润 * (增长率 + 股息率) * 合理PE倍数
    
    参数:
        净利润: 最近12个月的净利润
        营收增长率: 预期营收增长率（如0.20表示20%）
        股息率: 股息收益率（如0.03表示3%）
        合理PE倍数: 根据行业和成长阶段调整的合理PE
    
    返回:
        合理市值
    """
    # 计算增长率+股息率（林奇公式的核心）
    增长因子 = 营收增长率 + 股息率
    
    # 限制增长因子在合理范围（0-1之间）
    增长因子 = max(0, min(1.0, 增长因子))
    
    # 计算合理市值
    合理市值 = 净利润 * (1 + 增长因子) * 合理PE倍数
    
    return 合理市值


def 基于市值的目标价格(合理市值, 当前市值, 当前价格):
    """
    根据合理市值计算目标价格
    """
    if 当前市值 > 0:
        价格倍数 = 合理市值 / 当前市值
        目标价格 = 当前价格 * 价格倍数
    else:
        目标价格 = 当前价格 * 1.1
    
    # 限制目标价格范围
    目标价格 = max(当前价格 * 0.8, min(目标价格, 当前价格 * 2.5))
    
    return 目标价格
```

**实施优先级**：**中** - 需要获取盈利增长率数据，实现复杂度中等

---

### 4. 止损策略优化：ATR动态止损

#### 4.1 当前问题

**问题描述**：
- 止损价格 = 当前价格 * 0.85（固定15%）
- 对于低波动率（Beta低）的银行股，15%的跌幅可能意味着基本面崩塌
- 对于高Beta的科技股或加密货币相关股票，15%可能只是正常的周内波动
- 固定止损容易在震荡市被"扫损出局"

**影响**：
- 低波动股票止损过宽，风险控制不足
- 高波动股票止损过窄，容易被正常波动触发

#### 4.2 优化方案：ATR动态止损

**核心思路**：使用**ATR（平均真实波幅）**来动态计算止损价格，适应不同股票的波动性。

**算法实现**：

```python
def 计算ATR(历史价格数据, ATR周期=14):
    """
    计算平均真实波幅（Average True Range, ATR）
    
    参数:
        历史价格数据: DataFrame，包含High, Low, Close列
        ATR周期: 计算ATR的周期（通常为14天）
    
    返回:
        ATR值（标量）
    """
    import pandas as pd
    import numpy as np
    
    # 计算True Range的三个组成部分
    high_low = 历史价格数据['High'] - 历史价格数据['Low']
    high_close_prev = abs(历史价格数据['High'] - 历史价格数据['Close'].shift(1))
    low_close_prev = abs(历史价格数据['Low'] - 历史价格数据['Close'].shift(1))
    
    # True Range = max(high-low, high-close_prev, low-close_prev)
    true_range = pd.concat([high_low, high_close_prev, low_close_prev], axis=1).max(axis=1)
    
    # ATR = True Range的移动平均
    atr = true_range.rolling(window=ATR周期).mean()
    
    # 返回最新的ATR值
    return float(atr.iloc[-1]) if not atr.empty else None


def 计算ATR止损价(买入价格, 历史价格数据, ATR周期=14, ATR倍数=2.5, 最小止损幅度=0.05):
    """
    基于ATR计算动态止损价格
    
    参数:
        买入价格: 买入时的价格
        历史价格数据: DataFrame，包含High, Low, Close列
        ATR周期: 计算ATR的周期（通常为14天）
        ATR倍数: ATR的倍数（通常为2.0-3.0，波动率高的股票用更大倍数）
        最小止损幅度: 最小止损幅度（如0.05表示5%，作为兜底）
    
    返回:
        止损价格
    """
    # 计算ATR
    atr = 计算ATR(历史价格数据, ATR周期)
    
    if atr is None or atr <= 0:
        # 如果无法计算ATR，使用最小止损幅度
        止损价格 = 买入价格 * (1 - 最小止损幅度)
    else:
        # 基于ATR计算止损价格
        ATR止损价格 = 买入价格 - (atr * ATR倍数)
        
        # 硬止损价格（最小止损幅度）
        硬止损价格 = 买入价格 * (1 - 最小止损幅度)
        
        # 取两者中更保守的（止损价格更低）
        止损价格 = min(ATR止损价格, 硬止损价格)
    
    return 止损价格


def 根据Beta调整ATR倍数(股票Beta, 基础ATR倍数=2.5):
    """
    根据股票的Beta值调整ATR倍数
    
    逻辑:
    - Beta高（>1.5）-> 波动大 -> 使用更大的ATR倍数（更宽的止损）
    - Beta低（<0.8）-> 波动小 -> 使用更小的ATR倍数（更窄的止损）
    
    参数:
        股票Beta: 股票的Beta值（相对于市场）
        基础ATR倍数: 基础ATR倍数（通常为2.5）
    
    返回:
        调整后的ATR倍数
    """
    if 股票Beta > 1.5:
        # 高Beta股票，使用更大的倍数（更宽止损）
        调整倍数 = 基础ATR倍数 * 1.2
    elif 股票Beta > 1.2:
        调整倍数 = 基础ATR倍数 * 1.1
    elif 股票Beta < 0.8:
        # 低Beta股票，使用更小的倍数（更窄止损）
        调整倍数 = 基础ATR倍数 * 0.8
    elif 股票Beta < 1.0:
        调整倍数 = 基础ATR倍数 * 0.9
    else:
        调整倍数 = 基础ATR倍数
    
    # 限制倍数范围（1.5-4.0）
    调整倍数 = max(1.5, min(4.0, 调整倍数))
    
    return 调整倍数
```

**使用示例**：

```python
# 低波动股票（如银行股，Beta=0.8）
ATR倍数 = 根据Beta调整ATR倍数(0.8, 2.5)  # 约2.0
止损价格 = 计算ATR止损价(100, 历史数据, 14, ATR倍数, 0.05)
# 结果：止损价格可能为95（5%止损）

# 高波动股票（如科技股，Beta=1.8）
ATR倍数 = 根据Beta调整ATR倍数(1.8, 2.5)  # 约3.0
止损价格 = 计算ATR止损价(100, 历史数据, 14, ATR倍数, 0.05)
# 结果：止损价格可能为88（12%止损）
```

**实施优先级**：**高** - 能显著提升止损策略的适应性

---

### 5. 行业分类细化：增加二级行业标签

#### 5.1 当前问题

**问题描述**：
- 行业分类较粗（7大类）
- AI时代，半导体（Semiconductor）和软件（SaaS）的估值逻辑差异巨大，虽然都属于Technology

**影响**：
- 无法针对不同子行业使用不同的估值逻辑
- 行业PE基准不够精确

#### 5.2 优化方案：二级行业分类

**算法实现**：

```python
def 细化行业分类(一级行业, 二级行业关键词):
    """
    根据关键词细化行业分类
    
    返回:
        (一级行业, 二级行业) 元组
    """
    二级行业映射 = {
        'technology': {
            'hardware': ['semiconductor', 'chip', 'hardware', 'equipment', 'device'],
            'software': ['software', 'saas', 'cloud', 'platform', 'application'],
            'internet': ['internet', 'e-commerce', 'social', 'media', 'streaming'],
            'ai_ml': ['artificial intelligence', 'machine learning', 'ai', 'deep learning']
        },
        'healthcare': {
            'pharmaceutical': ['pharmaceutical', 'drug', 'medicine'],
            'biotech': ['biotech', 'biotechnology', 'biopharma'],
            'medical_device': ['medical device', 'equipment', 'instrument'],
            'healthcare_service': ['healthcare service', 'hospital', 'clinic']
        },
        'financial': {
            'bank': ['bank', 'banking', 'commercial bank'],
            'insurance': ['insurance', 'insurer'],
            'investment': ['investment', 'asset management', 'brokerage'],
            'fintech': ['fintech', 'financial technology', 'payment']
        },
        # ... 其他行业
    }
    
    # 匹配二级行业
    二级行业 = 'general'  # 默认
    if 一级行业 in 二级行业映射:
        for sub_industry, keywords in 二级行业映射[一级行业].items():
            if any(keyword in 二级行业关键词.lower() for keyword in keywords):
                二级行业 = sub_industry
                break
    
    return (一级行业, 二级行业)
```

**实施优先级**：**中** - 实现简单，但需要维护关键词映射表

---

### 6. 动态行业PE基准：使用ETF实时PE

#### 6.1 当前问题

**问题描述**：
- 使用写死的PE值（如Technology=25, Financial=12）
- 无法反映当前市场环境下行业估值的动态变化

#### 6.2 优化方案：使用行业ETF的实时PE

**算法实现**：

```python
def 获取动态行业基准PE(行业类别):
    """
    使用行业ETF作为基准锚点，获取动态行业PE
    
    参数:
        行业类别: 一级行业类别
    
    返回:
        行业基准PE（如果获取失败，返回默认值）
    """
    # 行业ETF映射
    sector_etf_map = {
        'technology': 'XLK',      # Technology Select Sector SPDR Fund
        'financial': 'XLF',       # Financial Select Sector SPDR Fund
        'healthcare': 'XLV',      # Health Care Select Sector SPDR Fund
        'energy': 'XLE',          # Energy Select Sector SPDR Fund
        'consumer': 'XLY',        # Consumer Discretionary Select Sector SPDR Fund
        'real_estate': 'VNQ',     # Vanguard Real Estate ETF
        'utility': 'XLU',         # Utilities Select Sector SPDR Fund
        'industrial': 'XLI',      # Industrial Select Sector SPDR Fund
        'materials': 'XLB',        # Materials Select Sector SPDR Fund
        'communication': 'XLC'    # Communication Services Select Sector SPDR Fund
    }
    
    # 默认PE值（如果无法获取ETF数据时使用）
    默认PE = {
        'technology': 25,
        'financial': 12,
        'healthcare': 22,
        'energy': 15,
        'consumer': 18,
        'real_estate': 15,
        'utility': 16,
        'industrial': 18,
        'materials': 16,
        'communication': 20,
        'general': 18
    }
    
    # 获取ETF代码
    etf_ticker = sector_etf_map.get(行业类别)
    if not etf_ticker:
        return 默认PE.get(行业类别, 18)
    
    # 尝试获取ETF的PE
    try:
        import yfinance as yf
        etf = yf.Ticker(etf_ticker)
        etf_info = etf.info
        
        # 获取PE（优先使用trailingPE，其次forwardPE）
        etf_pe = etf_info.get('trailingPE') or etf_info.get('forwardPE')
        
        if etf_pe and etf_pe > 0:
            return float(etf_pe)
        else:
            return 默认PE.get(行业类别, 18)
    except Exception as e:
        print(f"获取{etf_ticker}的PE失败: {e}")
        return 默认PE.get(行业类别, 18)
```

**实施优先级**：**中** - 实现简单，但需要处理API失败的情况

---

### 7. 数据源优化：接入专业API

#### 7.1 当前问题

**问题描述**：
- 依赖Yahoo Finance获取Put/Call Ratio、地缘政治风险指数等数据
- Yahoo Finance的免费API经常更改结构或限制访问
- Put/Call Ratio和地缘政治指数，Yahoo源并不稳定或根本没有直接提供结构化数据

#### 7.2 优化方案：多数据源策略

**推荐数据源**：

1. **美股数据**：
   - Alpha Vantage（免费，有API限制）
   - FMP Cloud（Financial Modeling Prep，付费但数据质量高）
   - Polygon.io（实时数据，付费）

2. **A股/H股数据**：
   - Tushare（国内，需要注册）
   - AkShare（开源，免费）

3. **期权数据**：
   - CBOE（芝加哥期权交易所，官方数据）
   - OptionMetrics（专业期权数据，付费）

4. **宏观经济数据**：
   - FRED（Federal Reserve Economic Data，免费）
   - Trading Economics（付费）

**实施优先级**：**低** - 需要付费API或处理多个数据源，实现复杂度高

---

### 实施路线图

#### 阶段一：高优先级优化（1-2周）

1. ✅ **PEG非线性修正** - 实现简单，效果显著
2. ✅ **ATR动态止损** - 核心功能优化
3. ✅ **PE分位点计算** - 需要历史数据，但逻辑清晰

#### 阶段二：中优先级优化（2-4周）

4. ✅ **动态行业PE基准** - 使用ETF实时PE
5. ✅ **目标价格计算优化** - PEG估值法或彼得·林奇法
6. ✅ **行业分类细化** - 增加二级行业标签

#### 阶段三：低优先级优化（长期）

7. ⏳ **数据源优化** - 接入专业API（需要评估成本和收益）

---

### 总结

这些优化建议旨在：

1. **消除硬编码**：用动态计算替代固定阈值
2. **提升适应性**：让算法适应不同市场环境
3. **增强准确性**：使用更科学的估值方法
4. **改善风控**：动态止损适应不同波动率

**建议优先实施**：
- PEG非线性修正（最简单，效果显著）
- ATR动态止损（核心风控优化）
- PE分位点计算（估值准确性提升）

这些优化将显著提升系统在极端市场环境下的表现，减少"魔法数字"带来的失真。

---

---

## 卖出策略（新功能）

系统在投资建议中提供**完整的卖出策略**，包括：

### 1. 止盈策略

- **目标价格到达时**：
  - 质量风格：分批卖出（分2-3批），保留部分仓位长期持有
  - 价值风格：一次性卖出或分2批卖出，锁定利润
  - 成长风格：分2批卖出，第一批在目标价格卖出50%，第二批在目标价格120%卖出剩余部分
  - 趋势风格：目标价格一次性卖出，快进快出

- **超过目标价格20%以上**：
  - 质量风格：逐步减仓，保留30-50%仓位继续持有
  - 其他风格：全部卖出锁定利润

### 2. 止损策略

- **动态止损价格**：基于ATR计算，或固定15%止损（取更保守的）
- **预警点设置**：止损价格上方5%，接近时密切关注
- **严格执行纪律**：一旦触及止损价格，立即全部卖出，不要犹豫

### 3. 分阶段卖出策略

- **分批建仓对应分批卖出**：
  - 第一批建仓 → 目标价格80%卖出
  - 第二批建仓 → 目标价格100%卖出
  - 第三批建仓 → 目标价格120%卖出

- **根据持有周期退出**：
  - 质量风格（1-3年）：持有1-3年后，即使未达到目标价格，也应考虑逐步减仓
  - 价值风格（6-12个月）：如果估值已修复，应全部卖出
  - 成长风格（3-6个月）：如果增长放缓，应逐步减仓
  - 趋势风格（1-3个月）：如果趋势转弱，应立即卖出

### 4. 特殊情况卖出

- **基本面恶化**：营收转为负增长或利润率大幅下降（下降超过30%），立即卖出
- **估值过高**：PE超过合理范围50%以上，考虑提前卖出锁定利润
- **市场系统性风险**：VIX>30或地缘政治风险>7，建议提前减仓50%或全部卖出

### 5. 卖出时机建议

- **避免在财报发布前卖出**（除非有明确风险信号）
- **避免在期权到期日附近卖出**（市场波动可能影响成交价格）
- **根据重要经济事件调整卖出时机**（美联储会议、CPI发布、中国央行会议等）

---

**文档版本**: v1.2.0  
**最后更新**: 2025-12  
**作者**: minmin

### 更新内容（v1.2.0）
- ✅ 新增ETF/基金识别与特殊分析框架
- ✅ 新增股票代码模糊搜索（支持港股前导0）
- ✅ 新增行业智能推断功能
- ✅ 新增重要经济事件分类显示（美国、中国、其他国家）
- ✅ 新增完整卖出策略（止盈、止损、分阶段卖出、特殊情况）
- ✅ 优化亏损公司估值逻辑（PE=0不再直接判断为"不好"）
- ✅ 修复ETF分析显示问题

